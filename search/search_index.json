{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to SpaCEX!","text":""},{"location":"#introduction","title":"Introduction","text":"<p>The limited research on spatial gene co-expression within tissues hinders leveraging spatial genomic context for versatile gene representations. We introduce SpaCEX, a groundbreaking few-shot, self-supervised learning model.   As shown in the figure above , SpaCEX generates semantically meaningful gene embeddings (SGEs) by identifying spatial gene co-expression patterns. Cofunctional and enrichment analyses of SGEs endorse their utility as genomic contexts, validated through relational semantics and exploration of gene functional ontology. Three novel SGE-based methods are proposed for enhancing FISH-based spatial transcriptomics, detecting spatially variable genes, and spatial clustering. Extensive real data results affirm the superior performance of these methods, highlighting the utility of SGEs for downstream tasks.</p>"},{"location":"Preparation/","title":"Preparation","text":""},{"location":"Preparation/#installation","title":"Installation","text":"<p>Downloading SpaCEX code from https://github.com/WLatSunLab/SpaCEX</p> <pre><code>git clone https://github.com/WLatSunLab/SpaCEX.git\n</code></pre> <p>Rename SpaCEX-main as SpaCEX</p>"},{"location":"Preparation/#download-data","title":"Download Data","text":"<p>You can get the mouse hippocampus dataset ssq-mHippo, the human dorsolateral prefrontal cortex datasets 10x-hDLPFC are available. The human breast cancer dataset 10x-hBC can be obtained. The mouse embryo dataset based on 10x Visium 10x-mEmb can be found. The mouse embryo dataset based on SeqFISH sqf-mEmb is obtainable. </p> <p>You can also obtain the example data here required for SpaCEX.and make sure these data are organized in the following structure:</p> <pre><code> . &lt;SpaCEX&gt;\n        \u251c\u2500\u2500 ...\n        \u251c\u2500\u2500 &lt;data&gt;\n        \u2502   \u251c\u2500\u2500 151676_10xvisium.h5ad\n        \u2502   \u251c\u2500\u2500 DLPFC_matrix_151676.dat\n        \u2502   \u2514\u2500\u2500 &lt;mEmb&gt;\n        \u2502       \u251c\u2500\u2500 10x_mEmb_matrix.dat\n        \u2502       \u251c\u2500\u2500 sqf_mEmb_adata.h5ad\n        \u2502       \u2514\u2500\u2500 qf_mEmb_matrix.dat\n        \u251c\u2500\u2500 &lt;model_pretrained&gt;\n        \u2502   \u2502\n        \u2514\u2500\u2500 ...\n\n</code></pre>"},{"location":"Preparation/#data-in-spacific-task","title":"Data in spacific task","text":""},{"location":"Preparation/#spacex-etc","title":"SpaCEX-ETC","text":"<pre><code>from SpaCEX.src.main.SpaCEX import SpaCEX\n## get data on 10x and sqf\nadata = SpaCEX_ETC.get_data(data='sqf', data_type='adata')\nadata, key_m, dataset_m = SpaCEX_ETC.data_process(adata)\n# key_m, dataset_m = SpaCEX_ETC.get_data(data='sqf', data_type='image')\nkey_v, dataset_v = SpaCEX_ETC.get_data(data='10x', data_type='image')\n</code></pre>"},{"location":"Preparation/#spacex-svg","title":"SpaCEX-SVG","text":"<pre><code>## get adata and image data\nadata= SpaCEX.get_data(sample_id='151676', data_type='adata')\ndataset, adata = SpaCEX.data_process(adata)\n</code></pre>"},{"location":"Preparation/#spacex-sc","title":"SpaCEX-SC","text":"<pre><code>## get adata and image data\nadata= SpaCEX.get_data(sample_id='151676', data_type='adata')\ndataset, adata = SpaCEX.data_process(adata)\n</code></pre>"},{"location":"SpaCEX/","title":"SGEs generation","text":""},{"location":"SpaCEX/#step1-load-data","title":"Step1: Load data","text":"<pre><code>from SpaCEX.src.main.SpaCEX import SpaCEX\nfrom sklearn.preprocessing import MinMaxScaler\nfrom scipy.cluster import hierarchy\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n</code></pre> <pre><code>## get adata and image data\nadata= SpaCEX.get_data(sample_id='151676', data_type='adata')\ndataset, adata = SpaCEX.data_process(adata)\ngene_name = adata.var.index.values\n</code></pre>"},{"location":"SpaCEX/#step2-generate-sges","title":"Step2: Generate SGEs","text":"<p><code>python  ## train model with pretrained model  y_pred, SGEs, model = SpaCEX.train(dataset=dataset, pretrain=False)  SGEs = SGEs.detach().cpu().numpy()</code></p> <pre><code>adata2image: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18639/18639 [05:25&lt;00:00, 57.27gene/s]\n</code></pre>"},{"location":"SpaCEX/#step3-hierarchical-clustering","title":"Step3: Hierarchical clustering","text":"<pre><code>## select the gene family\nkey_select = ['KRT1', 'KRT5', 'KRT7', 'KRT86', 'KRT81', 'KRT83', 'KRT6B', 'KRT6A', 'KRT8', 'KRT23', 'KRT33B', 'KRT31', 'KRT37',\n               'HLA-A', 'HLA-E', 'HLA-C', 'HLA-F', 'HLA-B',\n              'HLA-DRA', 'HLA-DRB5', 'HLA-DRB1', 'HLA-DQA1', 'HLA-DQB1', 'HLA-DQA2', 'HLA-DQB2', 'HLA-DPA1', 'HLA-DPB1'\n              ]\ncombined_data = zip(gene_name, SGEs)\nemb = dict(combined_data)\nemb = {key:emb[key] for key, value in emb.items() if key in key_select}\nmy_dict = {}\nfor key in emb.keys():\n    my_dict[key] = np.array(emb[key]).flatten()\nsorted_dict = dict(sorted(my_dict.items(), key=lambda x: key_select.index(x[0])))\nsorted_dict_value = np.array(list(sorted_dict.values()))\nscaler = MinMaxScaler()\n</code></pre> <pre><code>## norm the data\nnormalized_array = scaler.fit_transform(sorted_dict_value.T).T\nmy_dict_norm = {}\nfor i in range(len(sorted_dict)):\n    key = list(sorted_dict.keys())[i]\n    my_dict_norm[key] = normalized_array[i]\n</code></pre> <pre><code>## plot hierarchical clustering results\ndf = pd.DataFrame.from_dict(my_dict_norm, orient='index')\n\nsns.set(font_scale=2.5, font='sans-serif')\nrow_colors = ['#00C5CD'] * 13 + ['#1E90FF'] * 5 + ['#CD3333'] * 9\n\n## hierarchical clustering\nrow_linkage = hierarchy.linkage(df, method='average')\ncol_linkage = hierarchy.linkage(df.transpose(), method='average')\n\n# plot heatmap\nsns.set(font_scale=1., font='sans-serif' )\nsns.clustermap(df, row_linkage=row_linkage, col_linkage=col_linkage, cmap='coolwarm', row_colors=[row_colors], figsize=(10,8))\n\nplt.show()\n</code></pre>"},{"location":"SpaCEX_ETC/","title":"Enhancement of the transcriptomic coverage in Fish-based ST","text":""},{"location":"SpaCEX_ETC/#step1-load-10x-memb-and-sqf-memb","title":"Step1: Load 10x-mEmb and sqf-mEmb","text":"<pre><code>from SpaCEX.src.SpaCEX_ETC.src.main.SpaCEX_ETC import SpaCEX_ETC\n</code></pre> <pre><code># get data on 10x and sqf\nadata = SpaCEX_ETC.get_data(data='sqf', data_type='adata')\nadata, key_m, dataset_m = SpaCEX_ETC.data_process(adata)\n#key_m, dataset_m = SpaCEX_ETC.get_data(data='sqf', data_type='image')\nkey_v, dataset_v = SpaCEX_ETC.get_data(data='10x', data_type='image')\n</code></pre>"},{"location":"SpaCEX_ETC/#step2-train-the-spacex-etc","title":"Step2: Train the SpaCEX-ETC","text":"<pre><code># load pretrained SpaCEX\nmodel = SpaCEX_ETC.load_model()\nall_gmat_v2m, all_gmat_m2v = SpaCEX_ETC.data_filter(key_v, dataset_v, key_m, dataset_m)\n</code></pre> <pre><code>Gen, SGEs = SpaCEX_ETC.train_ETC(adata, all_gmat_v2m, all_gmat_m2v, model)\n</code></pre> <pre><code>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 100/100 [00:46&lt;00:00,  2.13it/s]\n</code></pre>"},{"location":"SpaCEX_ETC/#step3-generate-genes-expression-image-on-the-test-set","title":"Step3: Generate genes expression image on the test set","text":"<pre><code>img_gen = SpaCEX_ETC.sqf_gen(Gen, SGEs, adata)\n</code></pre> <pre><code>import matplotlib.pyplot as plt\nimport torch\nimport numpy as np\nfig, axs = plt.subplots(3, 3, figsize = (12,15), dpi=300)\nidx=329\nkey_m = np.array(list(all_gmat_m2v.keys()))\n# real visium\nimg_real = torch.tensor(all_gmat_v2m[key_m[301]])\nimg_real = img_real.squeeze(0)\nimg_real = img_real.cpu().detach().numpy()\naxs[0, 0].imshow(img_real, cmap='Greys', interpolation='nearest')\naxs[0, 0].set_title(key_m[301])\naxs[0, 0].axis('off')\n\n# real img\nimg_real = torch.tensor(all_gmat_m2v[key_m[301]])\nimg_real = img_real.squeeze(0)\nimg_real = img_real.cpu().detach().numpy()\naxs[0, 1].imshow(img_real, cmap='Greys', interpolation='nearest')\naxs[0, 1].set_title('real_{}'.format(key_m[301]))\naxs[0, 1].axis('off')\n\n# gen img\nimg_fake = img_gen[301]\naxs[0, 2].imshow(img_fake, cmap='Greys', interpolation='nearest')\naxs[0, 2].set_title('gen_{}'.format(key_m[301]))\naxs[0, 2].axis('off')\n\n# real visium\nimg_real = torch.tensor(all_gmat_v2m[key_m[308]])\nimg_real = img_real.squeeze(0)\nimg_real = img_real.cpu().detach().numpy()\naxs[1, 0].imshow(img_real, cmap='Greys', interpolation='nearest')\naxs[1, 0].set_title(key_m[308])\naxs[1, 0].axis('off')\n\n# real img\nimg_real = torch.tensor(all_gmat_m2v[key_m[308]])\nimg_real = img_real.squeeze(0)\nimg_real = img_real.cpu().detach().numpy()\naxs[1, 1].imshow(img_real, cmap='Greys', interpolation='nearest')\naxs[1, 1].set_title('real_{}'.format(key_m[308]))\naxs[1, 1].axis('off')\n\n# gen img\nimg_fake = img_gen[308]\naxs[1, 2].imshow(img_fake, cmap='Greys', interpolation='nearest')\naxs[1, 2].set_title('gen_{}'.format(key_m[308]))\naxs[1, 2].axis('off')\n\n# real visium\nimg_real = torch.tensor(all_gmat_v2m[key_m[324]])\nimg_real = img_real.squeeze(0)\nimg_real = img_real.cpu().detach().numpy()\naxs[2, 0].imshow(img_real, cmap='Greys', interpolation='nearest')\naxs[2, 0].set_title(key_m[324])\naxs[2, 0].axis('off')\n\n# real img\nimg_real = torch.tensor(all_gmat_m2v[key_m[324]])\nimg_real = img_real.squeeze(0)\nimg_real = img_real.cpu().detach().numpy()\naxs[2, 1].imshow(img_real, cmap='Greys', interpolation='nearest')\naxs[2, 1].set_title('real_{}'.format(key_m[324]))\naxs[2, 1].axis('off')\n\n# gen img\nimg_fake = img_gen[324]\naxs[2, 2].imshow(img_fake, cmap='Greys', interpolation='nearest')\naxs[2, 2].set_title('gen_{}'.format(key_m[324]))\naxs[2, 2].axis('off')\n\nplt.show()\n</code></pre> <pre><code>\n</code></pre>"},{"location":"SpaCEX_SC/","title":"SpaCEX-SC","text":""},{"location":"SpaCEX_SC/#step1-load-data","title":"Step1: Load data","text":"<pre><code>from sklearn.metrics.cluster import normalized_mutual_info_score\nfrom collections import OrderedDict\nfrom sklearn.metrics import adjusted_rand_score\nfrom SpaCEX.src.SpaCEX_SVG.utils import simu_zinb\nfrom SpaCEX.src.SpaCEX_SVG.utils import get_svg_score\nfrom SpaCEX.src.SpaCEX_SC.SpaCEX_SC import SpaCEX_SC\nfrom SpaCEX.src.main.SpaCEX import SpaCEX\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport scanpy as sc\nimport numpy as np\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n</code></pre> <pre><code>## get adata and image data\nadata= SpaCEX.get_data(sample_id='151676', data_type='adata')\ndataset, adata = SpaCEX.data_process(adata)\n</code></pre> <pre><code>adata2image: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18639/18639 [05:27&lt;00:00, 56.85gene/s]\n</code></pre>"},{"location":"SpaCEX_SC/#step2-generate-svg-score-by-spacex-svg","title":"Step2: Generate SVG score by SpaCEX-SVG","text":"<pre><code>## train model with pretrained model\ny_pred, SGEs, model = SpaCEX.train(dataset=dataset, pretrain=False)\n</code></pre> <pre><code>use cuda: True\nload pretrained mae from SpaCEX/model_pretrained/SpaCEX.pkl\n\n\nClustering: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 30/30 [07:12&lt;00:00, 14.41s/it]\n</code></pre> <pre><code>## generate SVG score\nadata.X = adata.X.todense()\nsvg_score = get_svg_score(SGEs, dataset, adata, model, sim_times=10)\n</code></pre> <pre><code>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [02:27&lt;00:00, 14.76s/it]\n</code></pre>"},{"location":"SpaCEX_SC/#stpe3-carry-out-spacex-sc","title":"Stpe3: Carry out SpaCEX-SC","text":"<pre><code>## get original data\nadata= SpaCEX.get_data(sample_id='151676', data_type='adata')\n</code></pre> <pre><code>## select genes\nnew_samples_indices = SpaCEX_SC.gene_select(cluster_labels, svg_score, selection_percentage=0.5)\n</code></pre> <pre><code>select 9263 genes\n</code></pre> <pre><code>## spatial clustering\nadata = SpaCEX_SC.spatial_clustering(adata, new_samples_indices, n_clusters=7)\n</code></pre> <pre><code>Calculateing adj matrix using xy only...\nRun 1: l [0.01, 1000], p [0.0, 3421.9987256815807]\nRun 2: l [0.01, 500.005], p [0.0, 3416.00732421875]\nRun 3: l [0.01, 250.0075], p [0.0, 3392.22265625]\nRun 4: l [0.01, 125.00874999999999], p [0.0, 3299.90869140625]\nRun 5: l [0.01, 62.509375], p [0.0, 2971.17138671875]\nRun 6: l [0.01, 31.2596875], p [0.0, 2097.834228515625]\nRun 7: l [0.01, 15.63484375], p [0.0, 945.4818725585938]\nRun 8: l [0.01, 7.822421875], p [0.0, 304.0054626464844]\nRun 9: l [0.01, 3.9162109375], p [0.0, 84.49016571044922]\nRun 10: l [0.01, 1.9631054687499998], p [0.0, 21.678667068481445]\nRun 11: l [0.01, 0.9865527343749999], p [0.0, 4.903018474578857]\nRun 12: l [0.01, 0.49827636718749996], p [0.0, 0.5869753360748291]\nRun 13: l [0.25413818359374996, 0.49827636718749996], p [0.0016840696334838867, 0.5869753360748291]\nRun 14: l [0.37620727539062493, 0.49827636718749996], p [0.11651778221130371, 0.5869753360748291]\nRun 15: l [0.4372418212890624, 0.49827636718749996], p [0.304052472114563, 0.5869753360748291]\nRun 16: l [0.4677590942382812, 0.49827636718749996], p [0.43444645404815674, 0.5869753360748291]\nrecommended l =  0.48301773071289056\nStart at res =  0.7 step =  0.1\nInitializing cluster centers with louvain, resolution =  0.7\n\n\n2023-12-19 14:10:56.114599: I tensorflow/core/util/util.cc:169] oneDNN custom operations are on. You may see slightly different numerical results due to floating-point round-off errors from different computation orders. To turn them off, set the environment variable `TF_ENABLE_ONEDNN_OPTS=0`.\n\n\nEpoch  0\nEpoch  10\nRes =  0.7 Num of clusters =  7\nrecommended res =  0.7\nInitializing cluster centers with louvain, resolution =  0.7\nEpoch  0\nEpoch  10\nEpoch  20\nEpoch  30\nEpoch  40\nEpoch  50\nEpoch  60\nEpoch  70\nEpoch  80\nEpoch  90\nEpoch  100\nEpoch  110\nEpoch  120\nEpoch  130\nEpoch  140\nEpoch  150\nEpoch  160\nEpoch  170\nEpoch  180\nEpoch  190\nCalculateing adj matrix using xy only...\n</code></pre>"},{"location":"SpaCEX_SC/#stpe4-show-the-result","title":"Stpe4: Show the result","text":"<pre><code>## get ground truth \nadata.obs['Ground Truth']=adata.obs['layer_guess_reordered_short'] \n</code></pre> <pre><code>## caculate ARI and NMI\nlabel_pred = list(adata.obs['r_pred'])\nlabel_pred = np.array(label_pred).astype(int)\n\nground_truth = list(adata.obs['Ground Truth'])\ncategory_to_int = {category: idx for idx, category in enumerate(set(ground_truth))}\n\ni = 0\nfor key in category_to_int:\n    category_to_int[key] = i\n    i = i+1\n\nground = [category_to_int[category] for category in ground_truth]\n\nari = adjusted_rand_score(ground, label_pred)\nprint(\"ARI:\", ari)\n\nnmi = normalized_mutual_info_score(ground, label_pred)\nprint(\"NMI:\", nmi)\n\n</code></pre> <pre><code>ARI: 0.5170212162200523\nNMI: 0.6375916808656412\n</code></pre> <pre><code>## plot ground truth\ndomains=\"Ground Truth\"\nplot_color=[\"#F56867\",\"#FEB915\",\"#C798EE\",\"#59BE86\",\"#7495D3\",\"#D1D1D1\",\"#6D1A9C\",\"#15821E\",\"#3A84E6\",\"#997273\",\"#787878\",\"#DB4C6C\",\"#9E7A7A\",\"#554236\",\"#AF5F3C\",\"#93796C\",\"#F9BD3F\",\"#DAB370\",\"#877F6C\",\"#268785\"]\nnum_celltype=len(adata.obs[domains].unique())\nadata.uns[domains+\"_colors\"]=list(plot_color[:num_celltype])\nax=sc.pl.scatter(adata,alpha=1,x=\"x_array\",y=\"y_array\",color=domains,title=domains,color_map=plot_color,show=False,size=100000/adata.shape[0])\nax.set_aspect('equal', 'box')\nax.axes.invert_yaxis()\n\nplt.show()\n</code></pre> <p>\u200b    \u200b    </p> <pre><code>## adjust the color according to the Hungarian algorithm\ny_true = np.array(ground)\ny_pred = np.array(adata.obs['r_pred'])\ny_true = y_true.astype(np.int64)\nassert y_pred.size == y_true.size\nD = max(y_pred.max(), y_true.max()) + 1\nw = np.zeros((D, D), dtype=np.int64)\nfor i in range(y_pred.size):\n    w[y_pred[i], y_true[i]] += 1\n\nfrom scipy.optimize import linear_sum_assignment as linear_assignment\nind = (np.array(linear_assignment(w.max() - w))).transpose()\nadata.uns['r_pred_colors'] = np.array(adata.uns['Ground Truth_colors'])[ind[:, 1]]\n</code></pre> <pre><code>## plot pred map\ndomains=\"r_pred\"\nnum_celltype=len(adata.obs[domains].unique())\nax=sc.pl.scatter(adata,alpha=1,x=\"x_array\",y=\"y_array\",color=domains,title='pred ARI:{:.3f}'.format(ari),color_map=adata.uns['r_pred_colors'], show=False,size=100000/adata.shape[0])\nax.set_aspect('equal', 'box')\nax.axes.invert_yaxis()\n\nplt.show()\n</code></pre> <p>\u200b    \u200b    </p>"},{"location":"SpaCEX_SVG/","title":"SVG detection","text":""},{"location":"SpaCEX_SVG/#step1-load-data","title":"Step1: Load data","text":"<pre><code>from SpaCEX.src.SpaCEX_SVG.utils import simu_zinb\nfrom SpaCEX.src.SpaCEX_SVG.utils import get_svg_score\nfrom SpaCEX.src.main.SpaCEX import SpaCEX\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport scanpy as sc\nimport numpy as np\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n</code></pre> <pre><code>## get adata and image data\nadata= SpaCEX.get_data(sample_id='151676', data_type='adata')\ndataset, adata = SpaCEX.data_process(adata)\n</code></pre> <pre><code>adata2image: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18639/18639 [05:25&lt;00:00, 57.27gene/s]\n</code></pre>"},{"location":"SpaCEX_SVG/#step2-train-spacex-to-get-sges","title":"Step2: Train SpaCEX to get SGEs","text":"<pre><code>## train model with pretrained model\ny_pred, SGEs, model = SpaCEX.train(dataset=dataset, pretrain=False)\n</code></pre> <pre><code>use cuda: True\nload pretrained mae from SpaCEX/model_pretrained/SpaCEX.pkl\n\n\nClustering: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 30/30 [07:55&lt;00:00, 15.84s/it]\n</code></pre>"},{"location":"SpaCEX_SVG/#step3-generate-svg-score","title":"Step3: Generate SVG score","text":"<pre><code>## generate SVG score\nadata.X = adata.X.todense()\nsvg_score = get_svg_score(SGEs, dataset, adata, model, sim_times=10)\n</code></pre> <pre><code>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [02:29&lt;00:00, 14.93s/it]\n</code></pre>"},{"location":"SpaCEX_SVG/#step4-display-the-result","title":"Step4: Display the result","text":"<pre><code>## obtain spatial variable gene index\nascending_indices = np.argsort(svg_score)\ndescending_indices = ascending_indices[::-1]\n</code></pre> <pre><code>## get gene name from adata\ngene_name = adata.var.index.values\n</code></pre> <pre><code>## gene expression whitin high svg score\nplot_gene = gene_name[descending_indices[:4]]\n\nfig, axs = plt.subplots(2, 2, figsize=(8, 8))\n\nsc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[0], show=False, ax=axs[0, 0], title=plot_gene[0], vmax='p99')\nsc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[1], show=False, ax=axs[0, 1], title=plot_gene[1], vmax='p99')\nsc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[2], show=False, ax=axs[1, 0], title=plot_gene[2], vmax='p99')\nsc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[3], show=False, ax=axs[1, 1], title=plot_gene[3], vmax='p99')\n\nplt.tight_layout()\nplt.show()\n\n</code></pre> <pre><code>## gene expression whitin low svg score\nplot_gene = gene_name[ascending_indices[2:6]]\n\nfig, axs = plt.subplots(2, 2, figsize=(8, 8))\n\nsc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[0], show=False, ax=axs[0, 0], title=plot_gene[0], vmax='p99')\nsc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[1], show=False, ax=axs[0, 1], title=plot_gene[1], vmax='p99')\nsc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[2], show=False, ax=axs[1, 0], title=plot_gene[2], vmax='p99')\nsc.pl.spatial(adata, img_key=\"hires\", color=plot_gene[3], show=False, ax=axs[1, 1], title=plot_gene[3], vmax='p99')\n\nplt.tight_layout()\nplt.show()\n\n</code></pre>"},{"location":"Home/SpaCEX_SC/","title":"SpaCEX SC","text":"<pre><code>from sklearn.metrics.cluster import normalized_mutual_info_score\nfrom collections import OrderedDict\nfrom sklearn.metrics import adjusted_rand_score\nfrom SpaCEX.src.SpaCEX_SVG.utils import simu_zinb\nfrom SpaCEX.src.SpaCEX_SVG.utils import get_svg_score\nfrom SpaCEX.src.SpaCEX_SC.SpaCEX_SC import SpaCEX_SC\nfrom SpaCEX.src.main.SpaCEX import SpaCEX\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport scanpy as sc\nimport numpy as np\nimport warnings\nwarnings.filterwarnings(\"ignore\")\n</code></pre> <pre><code>## get adata and image data\nadata= SpaCEX.get_data(sample_id='151676', data_type='adata')\ndataset, adata = SpaCEX.data_process(adata)\n</code></pre> <pre><code>adata2image: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 18639/18639 [05:27&lt;00:00, 56.85gene/s]\n</code></pre> <pre><code>## train model with pretrained model\ny_pred, SGEs, model = SpaCEX.train(dataset=dataset, pretrain=False)\n</code></pre> <pre><code>use cuda: True\nload pretrained mae from SpaCEX/model_pretrained/SpaCEX.pkl\n\n\nClustering: 100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 30/30 [07:12&lt;00:00, 14.41s/it]\n</code></pre> <pre><code>## generate SVG score\nadata.X = adata.X.todense()\nsvg_score = get_svg_score(SGEs, dataset, adata, model, sim_times=10)\n</code></pre> <pre><code>100%|\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588| 10/10 [02:27&lt;00:00, 14.76s/it]\n</code></pre> <pre><code>## get original data\nadata= SpaCEX.get_data(sample_id='151676', data_type='adata')\n</code></pre> <pre><code>## select genes\nnew_samples_indices = SpaCEX_SC.gene_select(cluster_labels, svg_score, selection_percentage=0.5)\n</code></pre> <pre><code>select 9263 genes\n</code></pre> <pre><code>## spatial clustering\nadata = SpaCEX_SC.spatial_clustering(adata, new_samples_indices, n_clusters=7)\n</code></pre> <pre><code>Calculateing adj matrix using xy only...\nRun 1: l [0.01, 1000], p [0.0, 3421.9987256815807]\nRun 2: l [0.01, 500.005], p [0.0, 3416.00732421875]\nRun 3: l [0.01, 250.0075], p [0.0, 3392.22265625]\nRun 4: l [0.01, 125.00874999999999], p [0.0, 3299.90869140625]\nRun 5: l [0.01, 62.509375], p [0.0, 2971.17138671875]\nRun 6: l [0.01, 31.2596875], p [0.0, 2097.834228515625]\nRun 7: l [0.01, 15.63484375], p [0.0, 945.4818725585938]\nRun 8: l [0.01, 7.822421875], p [0.0, 304.0054626464844]\nRun 9: l [0.01, 3.9162109375], p [0.0, 84.49016571044922]\nRun 10: l [0.01, 1.9631054687499998], p [0.0, 21.678667068481445]\nRun 11: l [0.01, 0.9865527343749999], p [0.0, 4.903018474578857]\nRun 12: l [0.01, 0.49827636718749996], p [0.0, 0.5869753360748291]\nRun 13: l [0.25413818359374996, 0.49827636718749996], p [0.0016840696334838867, 0.5869753360748291]\nRun 14: l [0.37620727539062493, 0.49827636718749996], p [0.11651778221130371, 0.5869753360748291]\nRun 15: l [0.4372418212890624, 0.49827636718749996], p [0.304052472114563, 0.5869753360748291]\nRun 16: l [0.4677590942382812, 0.49827636718749996], p [0.43444645404815674, 0.5869753360748291]\nrecommended l =  0.48301773071289056\nStart at res =  0.7 step =  0.1\nInitializing cluster centers with louvain, resolution =  0.7\n\n\n2023-12-19 14:10:56.114599: I tensorflow/core/util/util.cc:169] oneDNN custom operations are on. You may see slightly different numerical results due to floating-point round-off errors from different computation orders. To turn them off, set the environment variable `TF_ENABLE_ONEDNN_OPTS=0`.\n\n\nEpoch  0\nEpoch  10\nRes =  0.7 Num of clusters =  7\nrecommended res =  0.7\nInitializing cluster centers with louvain, resolution =  0.7\nEpoch  0\nEpoch  10\nEpoch  20\nEpoch  30\nEpoch  40\nEpoch  50\nEpoch  60\nEpoch  70\nEpoch  80\nEpoch  90\nEpoch  100\nEpoch  110\nEpoch  120\nEpoch  130\nEpoch  140\nEpoch  150\nEpoch  160\nEpoch  170\nEpoch  180\nEpoch  190\nCalculateing adj matrix using xy only...\n</code></pre> <pre><code>## get ground truth \nadata.obs['Ground Truth']=adata.obs['layer_guess_reordered_short'] \n</code></pre> <pre><code>## caculate ARI and NMI\nlabel_pred = list(adata.obs['r_pred'])\nlabel_pred = np.array(label_pred).astype(int)\n\nground_truth = list(adata.obs['Ground Truth'])\ncategory_to_int = {category: idx for idx, category in enumerate(set(ground_truth))}\n\ni = 0\nfor key in category_to_int:\n    category_to_int[key] = i\n    i = i+1\n\nground = [category_to_int[category] for category in ground_truth]\n\nari = adjusted_rand_score(ground, label_pred)\nprint(\"ARI:\", ari)\n\nnmi = normalized_mutual_info_score(ground, label_pred)\nprint(\"NMI:\", nmi)\n\n</code></pre> <pre><code>ARI: 0.5170212162200523\nNMI: 0.6375916808656412\n</code></pre> <pre><code>## plot ground truth\ndomains=\"Ground Truth\"\nplot_color=[\"#F56867\",\"#FEB915\",\"#C798EE\",\"#59BE86\",\"#7495D3\",\"#D1D1D1\",\"#6D1A9C\",\"#15821E\",\"#3A84E6\",\"#997273\",\"#787878\",\"#DB4C6C\",\"#9E7A7A\",\"#554236\",\"#AF5F3C\",\"#93796C\",\"#F9BD3F\",\"#DAB370\",\"#877F6C\",\"#268785\"]\nnum_celltype=len(adata.obs[domains].unique())\nadata.uns[domains+\"_colors\"]=list(plot_color[:num_celltype])\nax=sc.pl.scatter(adata,alpha=1,x=\"x_array\",y=\"y_array\",color=domains,title=domains,color_map=plot_color,show=False,size=100000/adata.shape[0])\nax.set_aspect('equal', 'box')\nax.axes.invert_yaxis()\n\nplt.show()\n</code></pre> <p>\u200b    \u200b    </p> <pre><code>## adjust the color according to the Hungarian algorithm\ny_true = np.array(ground)\ny_pred = np.array(adata.obs['r_pred'])\ny_true = y_true.astype(np.int64)\nassert y_pred.size == y_true.size\nD = max(y_pred.max(), y_true.max()) + 1\nw = np.zeros((D, D), dtype=np.int64)\nfor i in range(y_pred.size):\n    w[y_pred[i], y_true[i]] += 1\n\nfrom scipy.optimize import linear_sum_assignment as linear_assignment\nind = (np.array(linear_assignment(w.max() - w))).transpose()\nadata.uns['r_pred_colors'] = np.array(adata.uns['Ground Truth_colors'])[ind[:, 1]]\n</code></pre> <pre><code>## plot pred map\ndomains=\"r_pred\"\nnum_celltype=len(adata.obs[domains].unique())\nax=sc.pl.scatter(adata,alpha=1,x=\"x_array\",y=\"y_array\",color=domains,title='pred ARI:{:.3f}'.format(ari),color_map=adata.uns['r_pred_colors'], show=False,size=100000/adata.shape[0])\nax.set_aspect('equal', 'box')\nax.axes.invert_yaxis()\n\nplt.show()\n</code></pre> <p>\u200b    \u200b    </p>"}]}